"""Classes used to represent fitted data and models.
"""

from collections.abc import Collection
from dataclasses import dataclass
from typing import Any, Callable, Optional, Self

from .common import np, sp
from .options import FittingOptions
from .facade import poly_fit, nonline_fit
from .utils import get_metrics


@dataclass(frozen=True)
class ModelLite:
    """Readonly fitting result, containing both original and processed data,
    as well as callable model function."""

    data_raw: np.ndarray  # Original training data
    data_fit: np.ndarray  # Generated model fit
    model: Callable[[float | np.ndarray], float]  # Labdified fitted model
    coeffs: list[float]  # Model weights


@dataclass(frozen=True)
class ModelMetrics:
    """Readonly container for main model stats, that can be used to evaluate
    fitting effectiveness"""

    rse: float  # Residual Squared Error
    mse: float  # Mean Squared Error
    sigma: float  # Standard deviation
    std: float  # Standard error
    r_sq: float  # Determination coefficient
    corr: float  # Correlation coefficient
    ccord: float  # Concordance coefficient


class Model:
    """Comprehensive model class, containing additional analysis methods, such
    as metrics calculations, terms and spectra extraction, and additional
    fitting options and predictions."""

    def __init__(self, data_raw: np.ndarray) -> None:
        self.data_raw = data_raw
        # Private fields
        self.__data_fit: Optional[np.ndarray] = None
        self.__model: Optional[Callable[[float], float]] = None
        self.__expr: Optional[sp.Expr] = None
        self.__coeffs: Optional[list[float]] = None

    def is_fitted(self) -> bool:
        """Contains `True` when this model was already fitted, `False` otherwise."""
        return self.__model is not None

    def poly_fit(self, rank: int, update: bool = False) -> np.ndarray:
        """Internal call to `poly_fit` that fits this model using LMS method.
        It can update internal fields of the instance, after which it qualifies
        as being fitted.

        Arguments:
            rank -- specifies the amount of terms/coeffs for the polynomial.
            update -- if set `True`, makes this method put replace internal
            generated model data. Default value is `False`.
        Returns:
            NdArray of data generated by fitted model.
        """
        lite = poly_fit(self.data_raw, rank)
        if update:
            self.__data_fit = lite.data_fit
            self.__model = lite.model
            self.__coeffs = lite.coeffs
            self.__expr = sp.Poly(lite.coeffs, sp.Symbol("x"))
        return self.__data_fit

    def nonline_fit(
        self,
        expr: str,
        var: str = "x",
        options: FittingOptions = FittingOptions(),
        update: bool = True,
    ) -> np.ndarray:
        """Internal call to `nonline_fit` that fits this model using experimental
        methods from this library. It can update internal fields of the instance,
        after which it qualifies as being fitted.

        Arguments:
            expr -- string representation of a mathematical model using standard
            notation for inline expressions.
            var -- denotes main variable in expression. Default value is `"x"`.
            options -- FittingOptions instance that describes how to conduct the
            operation. Uses default options if not specified.
            update -- if set `True`, makes this method put replace internal
            generated model data. Default value is `True`.
        Returns:
            NdArray of data generated by fitted model.
        """
        model: Model = nonline_fit(self.data_raw, expr, var, options)
        if update:
            self.__data_fit = model.data_fit
            self.__model = model.as_lambda()
            self.__expr = model.expr
            self.__coeffs = model.coeffs

        return self.__data_fit

    @classmethod
    def __only_fitted(cls: type, func: Callable[[Self], Any]) -> Callable[[Self], Any]:
        """Internal class decorator to guard against methods being called before
        the model was fitted."""

        def inner(self: cls) -> Any:
            if not self.is_fitted():
                raise RuntimeError("Unable to call unfitted model.")
            func(self)

        return inner

    @property
    @__only_fitted
    def data_fit(self) -> np.ndarray:
        """Return data generated with fitted model."""
        return self.__data_fit

    @property
    @__only_fitted
    def coeffs(self) -> list[float]:
        """Return weights of the fitted model."""
        return self.__coeffs

    @property
    @__only_fitted
    def expr(self) -> sp.Expr:
        """Return symbolic representation of the fitted model."""
        return self.__expr

    @__only_fitted
    def __call__(self, data: float | np.ndarray) -> float | np.ndarray:
        """This overload calls internal models to generate fitted values."""
        if data is float:
            return self.__model(data)
        if isinstance(data, (Collection, np.ndarray)):
            fitted = np.ndarray(data.shape)
            with np.nditer(data, flags=["f_index"]) as it:
                for val in it:
                    fitted[it.index] = self.__model(val)
            return fitted

        raise ValueError("Invalid argument, model can only accept float or array-like.")

    @__only_fitted
    def as_lambda(self) -> Callable[[float | np.ndarray], float | np.ndarray]:
        """Return a lambda that generates fitted model values."""
        return self.__model

    @__only_fitted
    def as_lite(self) -> ModelLite:
        """Return a simplified immutable representation of the model."""
        return ModelLite(self.data_raw, self.data_fit, self.__model, self.__coeffs)

    @__only_fitted
    def metrics(self) -> ModelMetrics:
        """Return all relevant metrics for this model."""
        return get_metrics(self)
