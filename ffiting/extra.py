from typing import Callable
from .common import *

import ffiting.polys as pl


def poly_fit(data: np.ndarray, rank: int, length: int = 0) -> np.ndarray:
    """
    Uses Least Squares Method (LSM) to generate polynomial fitted values for
    the given data. Can use different ranked polynomials as basis.

    Args:
        data (np.ndarray): Given data for fitting.
        rank (int): Specifies polynomial rank to use.
        length (int, optional): Determines the amount of data that needs to be
        generated using fitted function. Can be used for extrapolation. Defaults
        to 0, which means generate array equal in length to the data array.

    Raises:
        ValueError: If length is lesser than 0 or an invalid value.
        ValueError: If rank is lesser than 2 or supersedes the maximum known
        polynomial rank.

    Returns:
        np.ndarray: Array of values generated using LSM.
    """
    # Determine bounds
    if length == 0:
        length = data.size
    if length < 0:
        raise ValueError("Bounds specified are invalid.")
    # Deal with the rank
    if rank >= 1 and rank <= 10:
        # Pick poly model
        poly = pl.polys[rank - 1]
        coeffs_p = sp.poly(poly, pl.t).coeffs()
        # Fit it
        coeffs_v = np.polyfit(np.arange(data.size), data, rank - 1)
        for i, c in enumerate(coeffs_p):
            poly = poly.subs(c, coeffs_v[i])
        poly = sp.lambdify(pl.t, poly)
        # Calculate values
        poly_y = np.ndarray(length)
        with np.nditer(poly_y, op_flags=["readwrite"], flags=["f_index"]) as it:
            for value in it:
                value[...] = poly(it.index)
        return poly_y
    else:
        raise ValueError("Number of coeffs must be withing [2 - 10] range.")


def dsb_fit(
    expression: str,
    main_var: str,
    data: np.ndarray,
    rank: int = 0,
    as_lambda: bool = False,
    numeric: bool = True,
    discretes: bool = True,
    maxfev: int = 100000,
    length: int = 0,
) -> np.ndarray | Callable:
    """
    Uses Differential Spectra Balance (DSB) to fit nonlinear function for given
    data. This is RnD function, so it may not work for every circumstances,
    mainly if underlying nonlinear system of functions is unsolvable.

    Args:
        expression (str): Trend model given in normal notation.
        main_var (str): Letter that represents main depended variable.
        data (np.ndarray): Given data for fitting.
        rank (int, optional): Determines rank used for underlying polynomial
        data representation. Guarantied fitting failure if given rank is lesser
        than amount of nonlinear model coefficients. Defaults to 0, which means
        use rank equal to the amount of nonlinear model coefficients.
        as_lambda (bool, optional): Specifies whether to return calculated values or trained model itself.
        numeric (bool, optional): Determines whether to run scipy's curve_fit
        discretes (bool, optional): Activates discrete balancing if True, or uses raw serries coeffs if False
        on DSB fitted data, or to just return it as is. Defaults to True.
        maxfev (int, optional): Determines max amount of numeric iterations to
        achieve adequate results. Omitted if numeric is false. Defaults to 100000.
        length (int, optional): Determines the amount of data that needs to be
        generated using fitted function. Can be used for extrapolation. Defaults
        to 0, which means generate array equal in length to the data array.

    Raises:
        ValueError: If length is lesser than 0 or an invalid value.
        ValueError: If rank is lesser than given nonlinear model coefficient
        count or supersedes the maximum known polynomial rank.
        RuntimeError: If no solutions for the nonlinear system of equations were
        found.

    Returns:
        np.ndarray: Array of values generated by the given nonlinear model,
        fitted using DSB.
    """
    # Parse given strings
    model = sp.parse_expr(expression)
    model_a = sorted(model.free_symbols, key=lambda s: s.name)

    var = sp.var(main_var)
    model_a.remove(var)

    # Determine bounds
    if length == 0:
        length = data.size
    if length < 0:
        raise ValueError("Bounds specified are invalid.")

    # Do the LSM thing (numpy territory)

    # Determine the poly rank here
    poly = pl.poly0
    if rank == 0:
        rank = len(model_a)
    if rank >= len(model_a) and rank <= 10:
        poly = pl.polys[rank - 1]
    else:
        raise ValueError("Number of coeffs must be withing [2 - 10] range.")
    # Calculate poly weights
    poly_vals = np.polyfit(np.arange(data.size), data, rank - 1)

    # Do the DSB thing (sympy territory)

    # Extract serries expansion's coeffs
    series_model = sp.series(model, var, n=rank).removeO()
    coeffs_m = sp.poly(series_model, var).coeffs()
    coeffs_p = sp.poly(poly, pl.t).coeffs()

    spectrum = []
    if discretes:
        # To balance discretes we need coeffs of a plain series
        # (the same curvature but without free coeffs)
        model_plain = model.copy()
        for a in model_a:
            model_plain = model_plain.subs(a, 1)
        series_plain = sp.series(model_plain, var, n=rank).removeO()
        coeffs_mp = sp.poly(series_plain, var).coeffs()
        # Get the spectrum and balance it against poly coeffs
        for i, a in enumerate(coeffs_m):
            spectrum.append(a / coeffs_mp[i])
    else:
        spectrum = coeffs_m

    balance = []
    for i, d in enumerate(spectrum):
        balance.append(sp.Eq(d, coeffs_p[i]))
    # Solve the resulting system against model's coeffs
    solution = sp.nonlinsolve(balance, model_a)
    if solution is sp.EmptySet:
        raise RuntimeError("No nonlinear solutions found for balance.")
    solution = list(solution)[0]

    # End of the road if no numeric(
    if numeric == False:
        # Substitute model with calculated poly weights
        for i, a in enumerate(model_a):
            model = model.subs(a, solution[i])
        for i, c in enumerate(coeffs_p):
            model = model.subs(c, poly_vals[i])
        # Calculate fitted values
        model = sp.lambdify(var, model)
    else:
        # Do the numeric thing (numpy and scipy territory)

        # Substitute solution with poly weights
        for i, c in enumerate(coeffs_p):
            solution = solution.subs(c, poly_vals[i])
        # Add main var to the front of the symbol list
        model_a.insert(0, var)
        # We need callable function to pass it into scipy
        model_l = sp.lambdify(model_a, model)
        # Scipy cannot work with sympy types(
        solution = np.array(solution).astype(np.float64)
        # Curve fit this thing!
        coeffs_n = sc.optimize.curve_fit(
            model_l, np.arange(data.size), data, p0=solution, maxfev=maxfev
        )
        model = lambda x: model_l(x, *coeffs_n[0])

    if as_lambda:
        return model
    else:
        # Calculate new fitted values
        model_y = np.ndarray(length)
        with np.nditer(model_y, op_flags=["readwrite"], flags=["f_index"]) as it:
            for value in it:
                value[...] = model(it.index)
        return model_y
